let mips = [
    {
        instruction: "sll $rd, $rt, shamt",
        rtl: "R[$rd] ← R[$rt] << shamt",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "shamt",
            func: "000000",
        },
        type: "R",
    },
    {
        instruction: "srl $rd, $rt, shamt",
        rtl: "R[$rd] ← R[$rt] >> shamt",
        notes: "Unsigned right shift ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "shamt",
            func: "000010",
        },
        type: "R",
    },
    {
        instruction: "sra $rd, $rt, shamt",
        rtl: "R[$rd] ← R[$rt] >> shamt",
        notes: "Signed right shift ",
        bitfields: {
            opcode: "000000",
            r1: "00000",
            r2: "rt",
            r3: "rd",
            shamt: "shamt",
            func: "000011",
        },
        type: "R",
    },
    {
        instruction: "sllv $rd, $rt, $rs",
        rtl: "R[$rd] ← R[$rt] << R[$rs]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "000100",
        },
        type: "R",
    },
    {
        instruction: "srlv $rd, $rt, $rs",
        rtl: "R[$rd] ← R[$rt] >> R[$rs]",
        notes: "Unsigned right shift ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "000110",
        },
        type: "R",
    },
    {
        instruction: "srav $rd, $rt, $rs",
        rtl: "R[$rd] ← R[$rt] >> R[$rs]",
        notes: "Signed right shift ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "000111",
        },
        type: "R",
    },
    {
        instruction: "jr $rs",
        rtl: "PC ← R[$rs]",
        notes: "R[$rs] must be a multiple of 4 ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "00000",
            r3: "00000",
            shamt: "00000",
            func: "001000",
        },
        type: "R",
    },
    {
        instruction: "jalr $rd, $rs",
        rtl: "tmp ← R[$rs]\nR[$rd] ← PC + 8\nPC ← tmp",
        notes: "R[$rs] must be a multiple of 4; Undefined if $rs = $rd ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "00000",
            r3: "rd",
            shamt: "00000",
            func: "001001",
        },
        type: "R",
    },
    {
        instruction: "jalr $rs",
        rtl: "(special form of “jalr $rd, $rs” where $rd = 31, implicitly) ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "00000",
            r3: "11111",
            shamt: "00000",
            func: "001001",
        },
        type: "R",
    },
    {
        instruction: "syscall",
        rtl: "System Call",
        bitfields: {
            opcode: "000000",
            r1: "00000",
            r2: "00000",
            r3: "00000",
            shamt: "00000",
            func: "001100",
        },
        type: "R",
    },
    {
        instruction: "mfhi $rd",
        rtl: "R[$rd] ← HI",
        bitfields: {
            opcode: "000000",
            r1: "00000",
            r2: "00000",
            r3: "rd",
            shamt: "00000",
            func: "010000",
        },
        type: "R",
    },
    {
        instruction: "mthi $rs",
        rtl: "HI ← R[$rs]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "00000",
            r3: "00000",
            shamt: "00000",
            func: "010001",
        },
        type: "R",
    },
    {
        instruction: "mflo $rd",
        rtl: "R[$rd] ← LO",
        bitfields: {
            opcode: "000000",
            r1: "00000",
            r2: "00000",
            r3: "rd",
            shamt: "00000",
            func: "010010",
        },
        type: "R",
    },
    {
        instruction: "mtlo $rs",
        rtl: "LO ← R[$rs]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "00000",
            r3: "00000",
            shamt: "00000",
            func: "010011",
        },
        type: "R",
    },
    {
        instruction: "mult $rs, $rt",
        rtl: "{HI, LO},{ ← R[$rs] * R[$rt]",
        notes: "Signed multiplication",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "00000",
            shamt: "00000",
            func: "011000",
        },
        type: "R",
    },
    {
        instruction: "multu $rs, $rt",
        rtl: "{HI, LO},{ ← R[$rs] * R[$rt]",
        notes: "Unsigned multiplication",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "00000",
            shamt: "00000",
            func: "011001",
        },
        type: "R",
    },
    {
        instruction: "div $rs, $rt",
        rtl: "LO ← R[$rs] / R[$rt]\nHI ← R[$rs] % R[$rt]",
        notes: "Signed division ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "00000",
            shamt: "00000",
            func: "011010",
        },
        type: "R",
    },
    {
        instruction: "divu $rs, $rt",
        rtl: "LO ← R[$rs] / R[$rt]\nHI ← R[$rs] % R[$rt]",
        notes: "Unsigned division ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "00000",
            shamt: "00000",
            func: "011011",
        },
        type: "R",
    },
    {
        instruction: "add $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] + R[$rt]",
        notes: "Exception on signed overflow ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100000",
        },
        type: "R",
    },
    {
        instruction: "addu $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] + R[$rt]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100001",
        },
        type: "R",
    },
    {
        instruction: "sub $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] - R[$rt]",
        notes: "Exception on signed overflow ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100010",
        },
        type: "R",
    },
    {
        instruction: "subu $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] - R[$rt]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100011",
        },
        type: "R",
    },
    {
        instruction: "and $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] & R[$rt]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100100",
        },
        type: "R",
    },
    {
        instruction: "or $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] | R[$rt]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100101",
        },
        type: "R",
    },
    {
        instruction: "xor $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] ^ R[$rt]",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100110",
        },
        type: "R",
    },
    {
        instruction: "nor $rd, $rs, $rt",
        rtl: "R[$rd] ← !(R[$rs] | R[$rt])",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "100111",
        },
        type: "R",
    },
    {
        instruction: "slt $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] < R[$rt]",
        notes: "Signed comparison ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "101010",
        },
        type: "R",
    },
    {
        instruction: "sltu $rd, $rs, $rt",
        rtl: "R[$rd] ← R[$rs] < R[$rt]",
        notes: "Unsigned comparison ",
        bitfields: {
            opcode: "000000",
            r1: "rs",
            r2: "rt",
            r3: "rd",
            shamt: "00000",
            func: "101011",
        },
        type: "R",
    },
    {
        instruction: "j address",
        rtl: "PC ← {(PC + 4)[31:28], address, 00},{ ",
        bitfields: {
            opcode: "000010",
            const: "target",
        },
        type: "J",
    },
    {
        instruction: "jal address",
        rtl: "R[31] ← PC + 8\nPC ← {(PC + 4)[31: 28], address,00},{ ",
        bitfields: {
            opcode: "000011",
            const: "target",
        },
        type: "J",
    },
    {
        instruction: "beq $rs, $rt, imm",
        rtl: "if(R[$rs] = R[$rt])\nPC ← PC + 4 + SignExt18b({imm,00},{)",
        bitfields: {
            opcode: "000100",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "bne $rs, $rt, imm",
        rtl: "if(R[$rs] != R[$rt])\nPC ← PC + 4 + SignExt18b({imm,00},{)",
        bitfields: {
            opcode: "000101",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "blez $rs, imm",
        rtl: "if(R[$rs] <= 0)\nPC ← PC + 4 + SignExt18b({imm,00},{)",
        notes: "Signed comparison ",
        bitfields: {
            opcode: "000110",
            r1: "rs",
            r2: "00000",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "bgtz $rs, imm",
        rtl: "if(R[$rs] > 0)\nPC ← PC + 4 + SignExt18b({imm,00},{)",
        notes: "Signed comparison ",
        bitfields: {
            opcode: "000111",
            r1: "rs",
            r2: "00000",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "addi $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] + SignExt16b(imm)",
        notes: "Exception on signed overflow ",
        bitfields: {
            opcode: "001000",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "addiu $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] + SignExt16b(imm)",
        bitfields: {
            opcode: "001001",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "slti $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] < SignExt16b(imm)",
        notes: "Signed comparison ",
        bitfields: {
            opcode: "001010",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "sltiu $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] < SignExt16b(imm)",
        notes: "Unsigned comparison ",
        bitfields: {
            opcode: "001011",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "andi $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] & {0 × 16, imm},{",
        bitfields: {
            opcode: "001100",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "ori $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] | {0 × 16, imm},{",
        bitfields: {
            opcode: "001101",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "xori $rt, $rs, imm",
        rtl: "R[$rt] ← R[$rs] ^ {0 × 16, imm},{",
        bitfields: {
            opcode: "001110",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "lui $rt, imm",
        rtl: "R[$rt] ← {(imm)[15:0], 0 × 16},{",
        bitfields: {
            opcode: "001111",
            r1: "rs",
            r2: "rt",
            const: "imm",
        },
        type: "I",
    },
    {
        instruction: "lb $rt, imm($rs)",
        rtl: "R[$rt] ← SignExt8b(Mem1B(R[$rs] + SignExt16b(imm)))",
        bitfields: {
            opcode: "100000",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "lh $rt, imm($rs)",
        rtl: "R[$rt] ← SignExt16b(Mem2B(R[$rs] + SignExt16b(imm)))",
        notes: "Computed address must be a multiple of 2 ",
        bitfields: {
            opcode: "100001",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "lw $rt, imm($rs)",
        rtl: "R[$rt] ← Mem4B(R[$rs] + SignExt16b(imm))",
        notes: "Computed address must be a multiple of 4 ",
        bitfields: {
            opcode: "100011",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "lbu $rt, imm($rs)",
        rtl: "R[$rt] ← {0 × 24, Mem1B(R[$rs] + SignExt16b(imm))},{",
        bitfields: {
            opcode: "100100",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "lhu $rt, imm($rs)",
        rtl: "R[$rt] ← {0 × 16, Mem2B(R[$rs] + SignExt16b(imm))},{",
        notes: "Computed address must be a multiple of 2 ",
        bitfields: {
            opcode: "100101",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "sb $rt, imm($rs)",
        rtl: "Mem1B(R[$rs] + SignExt16b(imm)) ← (R[$rt])[7:0]",
        bitfields: {
            opcode: "101000",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "sh $rt, imm($rs)",
        rtl: "Mem2B(R[$rs] + SignExt16b(imm)) ← (R[$rt])[15:0]",
        notes: "Computed address must be a multiple of 2 ",
        bitfields: {
            opcode: "101001",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
    {
        instruction: "sw $rt, imm($rs)",
        rtl: "Mem4B(R[$rs] + SignExt16b(imm)) ← R[$rt]",
        notes: "Computed address must be a multiple of 4 ",
        bitfields: {
            opcode: "101011",
            r1: "rs",
            r2: "rt",
            const: "offset",
        },
        type: "I",
    },
];
let formats = [
    {
        type: "R-Type",
        "31-26": "opcode",
        "25-21": "$rs",
        "20-16": "$rt",
        "15-11": "$rd",
        "10-06": "shamt",
        "05-00": "funct",
    },
    {
        type: "I-Type",
        "31-26": "opcode",
        "25-21": "$rs",
        "20-16": "$rt",
        "15-00": "imm",
    },
    {
        type: "J-Type",
        "31-26": "opcode",
        "25-00": "address",
    },
];

let registers = [
    {
        name: "$zero",
        number: "0",
        use: "The Constant Value 0",
        "across call safety": NaN,
    },
    {
        name: "$at",
        number: "1",
        use: "Assembler temporary",
        "across call safety": false,
    },
    {
        name: "$v0-$v1",
        number: "2-3",
        use: "Values for Function Results and Expression Evaluation",
        "across call safety": false,
    },
    {
        name: "$a0-$a3",
        number: "4-7",
        use: "Arguments",
        "across call safety": false,
    },
    {
        name: "$t0-$t7",
        number: "8-15",
        use: "Temporaries",
        "across call safety": false,
    },
    {
        name: "$s0-$s7",
        number: "16-23",
        use: "Saved Temporaries",
        "across call safety": true,
    },
    {
        name: "$t8-$t9",
        number: "24-25",
        use: "Temporaries",
        "across call safety": false,
    },
    {
        name: "$k0-$k1",
        number: "26-27",
        use: "Reserved for OS Kernel",
        "across call safety": false,
    },
    {
        name: "$gp",
        number: "28",
        use: "Global Pointer",
        "across call safety": true,
    },
    {
        name: "$sp",
        number: "29",
        use: "Stack Pointer",
        "across call safety": true,
    },
    {
        name: "$fp",
        number: "30",
        use: "Frame Pointer",
        "across call safety": true,
    },
    {
        name: "$ra",
        number: "31",
        use: "Return Address",
        "cross-call-safety": false,
    },
];
